---
layout: post
title:  "Любопытные паттерны в Java-программировании"
date:   2016-05-12 19:00:00
categories: java curious_patterns
---
<font color="red">THIS IS A DRAFT</font>
Сразу оговорюсь(Disclaimer, if you wish): эта заметка не является инструкцией к действию. Я не утверждаю, что надо делать так или иначе. Сдесь всего лишь собраны конструкции, которые произвели на меня впечатление любого рода, будь то понимание, что конструкция невероятно полезна или являет собой совершеннейший бред. Не важно. Просто имейте в виду, что так сделать можно, и не приписывайте мне выводов, вроде того стоит ли делать так или нет. Спасибо за понимание!


###Local return

Почернутый из опыта одного бывшего C-программиста, который в какой-то момент стал моим коллегой.
В его коде это выглядело как бесполезный цикл, на который я и обратил внимание. Примерно так вот:


{% highlight java %}
do{
	//lots of if checks
}while(false);
{% endhighlight %}

Расспросы прояснили, что эту конструкцию коллега перенес из своего опыта программирования на C. Суть конечно же не в самом цикле, выполняющемся лишь единожды, но в том, что из него можно в любой момент выйти с помощью ключевого слова **break**. Коллега описал эту конструкцию как "goto without being blamed for bad code". Я почувствовал некоторую необязательность цикла и решил её проверить. Как программист-практик я не читал спецификацию языка Java полностью. Лишь иногда заглядываю в неё при нужде или, как в этом случае, лёгком интересе. И в данном случае интерес был удовлетворен с лихвой. JLS7 (какая была под рукой) гласит:
    
	14.7 Labeled Statements
    Statements may have label prefixes.

Statements! Не Cycles, а  Statements! Раньше я полагал что это механизм для управлением потоком исполнения со многими вложенными циклами, но оказалось, что это механизм более общий. Тут же я набросал простой пример, который лишь продемонстрировал то, что я теперь знал.

{% highlight java %}
public static void main(String[] args)
{
	System.out.println("1");
	test :
	{
		System.out.println("2");
		if (true)	// эта проверка мешает компилятору 
				// понять что строка 3 недостежима
		{
			break test;
		}
		System.out.println("3");// 3
	}
	System.out.println("4");
}
{% endhighlight %}

Вывод программы:
{% highlight batch %}
1
2
4
{% endhighlight %}

Как видете, мы просто вышли из блока кода, не выполняя его до конца. В оригинальном коде было много проверок. Это был какой-то кусок валидатора. Логично было игнорировать остаток кода, если одна проверка провалилась. Тут конечно можно рассказывать, что надо было этот код сделать методом с логическим возвратным типом и в основном коде просто делать вызов в условии if. Мне лишь остаётся процитировать не помню кого именно: *Важен не инструмент, а то, как ты его используешь*. В конце концов цитата тоже инструмент и не важно кто сказал эти слова, важно ... ну вы поняли :-).

###Enum strategy

В Java enum - не просто набор констант. В какой-то момент было решено, что обычные константы в силе C небезопасны. Если у вас есть два статически импортированных класса с константами, имеющими одинаковое имя, никогда не знаешь какой из них ты используешь по имени константы. Это может привести к неприятным последствиям. Среда импортировала не то, а потом у тебя в базе данных в нужном поле не то значение. Если же от него зависит важная бизнесс-логика, то это вообще катастрофа. И, надо заметить, это не единственная проблема такого подхода. Посему было решено сделать перечислимые константы типо-безопасными. Сегодня каждый enum в Java это по сути *абстрактный класс*. Каждая "константа" внутри него - наследник этого класса. Теперь невозможно присвоить "константу" полю не того типа, не сделав при этом явных преобразований. Замечательно! Кроме того в Java инамы получили синтаксическую поддержку в самом языке, что сделало работу с ними ещё удобнее. Однако и на этом не всё. Поскольку enum это класс, появляется возможность наделить его некоторым поведением. Согласно заветам Линуса Торвальдса, сразу покажу код.

{% highlight java %}
enum Operation{
    ADD,
    MULTIPLY;

    abstract double apply(double a,double b);
}
{% endhighlight %}

Тут ваша среда разработки услужливо подсветит *ADD* и *MULTIPLY*. Ведь они по сути - подклассы, а значит должны дать реализацию абстрактному методу *apply*.

###
